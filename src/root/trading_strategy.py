'''
Created on Jan 29, 2022

@author: david
'''

import requests
import csv
from matplotlib import pyplot as plt
from datetime import datetime
from dateutil.relativedelta import relativedelta
import calendar

#API Key: OOW3ZHH028NNAMQN


# get_ticker_data is used to read in data from the AlphaVantage API
# the API exports data for one stock ticker that includes time and close value
#
# Parameters:
#    api_key: the AlphaVantage API key
#    ticker: the stock ticker being investigated
#    month: the month of ticker data exported (1 = current month, 12 = 12 months ago from the current date)
#
# Return Values:
#    times_by_day: the time of each data point for a month of data in a 2D array where each row is one day
#    close_by_day: the stock value at each time for a month of data in a 2D array where each row is one day
#
def get_ticker_data(api_key, ticker, month):
    
    #Read in the API data and store the times and close values in a 2D array
    url = 'https://www.alphavantage.co/query?function=TIME_SERIES_INTRADAY_EXTENDED&symbol=' + ticker + '&interval=30min&slice=year1' + 'month' + str(month) + '&apikey=' + api_key
    #Download the data as a CSV
    with requests.Session() as s:
        download = s.get(url)
        decoded_content = download.content.decode('utf-8')
        cr = csv.reader(decoded_content.splitlines(), delimiter=',')
        data_array = list(cr)
    
    #Separate the times and close value into two separate arrays
    data_close = []
    data_times = []
    for i in range(1,len(data_array)):  
        #Format the time data into a consistent time stamp format
        curr_dt = datetime.strptime(data_array[i][0], '%Y-%m-%d %H:%M:%S')
        #Only capture data that is within the standard market trading hours (9:30am-4pm EST)
        if  (curr_dt.hour*60 + curr_dt.minute < 570) or (curr_dt.hour*60 + curr_dt.minute > 960):
            continue
        data_times.insert(0,curr_dt)
        data_close.insert(0,float(data_array[i][4]))
    
    #Translate the 1 X n lists of times and close values to m X n arrays where each m array is one day's worth of data
    times_by_day = []
    close_by_day = []

    i = 0
    j = 0
    
    #Iterate through the entire 1D arrays of times and close values
    while i < len(data_times):
        start_index = i
        end = False
        j = i
        
        #Break the 1D array of data for a whole month into a 2D array where each row is one day's worth of data
        while end == False:
            try:
                #Detect if the end of a day is reached
                if (data_times[j].hour > data_times[j+1].hour):
                    end_index = j
                    i = end_index + 1
                    times_by_day.append(data_times[start_index:end_index+1])
                    close_by_day.append(data_close[start_index:end_index+1])
                    
                    end = True
                #If the end of the day is not reached, continue to the next data point
                else:
                    j += 1
            #Catch the error that's thrown when the end of the month is reached
            except IndexError:
                end_index = j
                end = True
                i = len(data_times)
    #Return the 2D arrays of time data and close value data by day
    return times_by_day, close_by_day, data_times, data_close


# calculate_return is the function used to calculate the return on investment if 
# the given trading strategy is used for the entire month
#
# Parameters:
#    pct_open: the pct change in a stock (either gain or loss) that triggers a position to open
#    pct_close: the return within the day that triggers the position to close
#    pct_stop_loss: the loss within the day that triggers the position to close
#    times_by_day: the 2D array of times generated by get_ticker_data
#    close_by_day: the 2D array of stock values generated by get_ticker_data
#
# Return Values:
#    The summation of all the daily gains/losses for the month being investigated, a.k.a monthly return on the given strategy
#
def calculate_return(pct_open, pct_close, pct_stop_loss, times_by_day, close_by_day, raw_time_data, raw_close_data, month, max_month):    
    #Array used to capture the details of which trades are executed to calculate returns and visualize the trades
    open_times = []
    open_vals = []
    close_times = []
    close_vals = []
    gain_loss = []
    
    print(pct_open)
    print(pct_close)
    
    #iterate through every day in the month
    for m in range(1, len(times_by_day)):
        #Initialize and reset values that are used on a daily basis
        n = 0
        start_val = close_by_day[m-1][-1]
        bought_to_open = False
        sold_to_close = False
        sold_to_open = False
        bought_to_close = False
        buy_to_open_val = 0
        sell_to_open_val = 0
        
        #iterate through each [time interval] in one day
        for n in range(0, len(times_by_day[m])-2):
            curr_time = times_by_day[m][n]
            curr_val = close_by_day[m][n]
            pct_change = (curr_val - start_val) / curr_val
            
            #buy to open if the pct_open is hit due to the stock price dropping
            if ((pct_change < -1*pct_open) and not sold_to_open and not bought_to_open):
                open_times.append(curr_time)
                open_vals.append(curr_val)
                buy_to_open_val = curr_val
                bought_to_open = True
            
            #sell to close...
            elif (bought_to_open and not sold_to_close):
                #if the pct_close is hit (daily target gain is realized)
                if ((curr_val - buy_to_open_val) / curr_val > pct_close): 
                    close_times.append(curr_time)
                    close_vals.append(curr_val)
                    gain_loss.append(buy_to_open_val * pct_close)
                    sold_to_close = True
                #if the pct_stop_loss is hit (limit loss target is hit)
                elif ((curr_val - buy_to_open_val) / curr_val < pct_stop_loss):
                    close_times.append(curr_time)
                    close_vals.append(curr_val)
                    gain_loss.append(buy_to_open_val * pct_stop_loss)
                    sold_to_close = True
                #if the end of the day is reached
                elif (n >= len(times_by_day[m]) - 3):
                    close_times.append(curr_time)
                    close_vals.append(curr_val)
                    gain_loss.append(curr_val - buy_to_open_val)

            
            #sell to open if the pct_open is hit due to stock price rising
            if (pct_change > pct_open and not bought_to_open and not sold_to_open):
                open_times.append(times_by_day[m][n])
                open_vals.append(close_by_day[m][n])
                sell_to_open_val = close_by_day[m][n]
                sold_to_open = True          
            
            #buy to close...
            elif (sold_to_open and not bought_to_close):
                #if the pct_close is hit (daily target gain is realized)
                if ((sell_to_open_val - curr_val) / curr_val > pct_close): 
                    close_times.append(curr_time)
                    close_vals.append(curr_val)
                    gain_loss.append(sell_to_open_val * pct_close)
                    bought_to_close = True
                #if the pct_stop_loss is hit (limit loss target is hit)
                elif ((sell_to_open_val - curr_val) / curr_val < pct_stop_loss):
                    close_times.append(curr_time)
                    close_vals.append(curr_val)
                    gain_loss.append(sell_to_open_val * pct_stop_loss)
                    bought_to_close = True
                #if the end of the day is reached
                elif (n >= len(times_by_day[m]) - 3):
                    close_times.append(curr_time)
                    close_vals.append(curr_val)
                    gain_loss.append(sell_to_open_val - curr_val)

        
    #Calculate the net profit/loss for the month
    result = 0
    gain_times = []
    gain_vals = []
    loss_times = []
    loss_vals = []
    for i in range(len(gain_loss)):
        result += gain_loss[i]
        if gain_loss[i] >= 0: 
            gain_times.append(close_times[i])
            gain_vals.append(close_vals[i])
        else:
            loss_times.append(close_times[i])
            loss_vals.append(close_vals[i])
    
    x_axis_scale = []
    for i in range(len(raw_time_data)):
        x_axis_scale.append(raw_time_data[i].day)

    formatted_list = [ '%.2f' % elem for elem in gain_loss]
    print('gain/loss:', formatted_list)
    
    curr_month = datetime.now().month
    display_month = curr_month + 1 - month
    plt.figure('Month: ' + calendar.month_name[display_month], figsize = [11,6])
    plt.plot(raw_time_data, raw_close_data, 'b-')
    plt.ylabel('Stock Price [$]')
    plt.xlabel('Date')
    plt.plot(open_times, open_vals, 'yo', label='Position Opened')
    plt.plot(gain_times, gain_vals, 'go', label='Position Closed for Profit')
    plt.plot(loss_times, loss_vals, 'ro', label='Position Closed for Loss')
    plt.legend()
    if (month == max_month): plt.show(block=False)

    #Return the net gain or loss for the month
    return [round(result,2)]

